{
  "openapi": "3.0.1",
  "info": {
    "title": "Rackspace Spot API Draft Specification.  Copyright (c) Rackspace Technologies.",
    "version": "v0.8.0"
  },
  "servers": [
    {
      "url": "/"
    }
  ],
  "security": [
    {
      "BearerToken": []
    }
  ],
  "paths": {
    "/apis/ngpc.rxt.io/v1/clouds": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind Cloud",
        "operationId": "listNgpcRxtIoV1CloudForAllNamespaces",
        "parameters": [
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/cloudspaces": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind CloudSpace",
        "operationId": "listNgpcRxtIoV1CloudSpaceForAllNamespaces",
        "parameters": [
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpaceList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpaceList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/clouds": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind Cloud",
        "operationId": "listNgpcRxtIoV1NamespacedCloud",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        }
      },
      "post": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "create a Cloud",
        "operationId": "createNgpcRxtIoV1NamespacedCloud",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete collection of Cloud",
        "operationId": "deleteNgpcRxtIoV1CollectionNamespacedCloud",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/clouds/{name}": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read the specified Cloud",
        "operationId": "readNgpcRxtIoV1NamespacedCloud",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Cloud",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace the specified Cloud",
        "operationId": "replaceNgpcRxtIoV1NamespacedCloud",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Cloud",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete a Cloud",
        "operationId": "deleteNgpcRxtIoV1NamespacedCloud",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Cloud",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gracePeriodSeconds",
            "in": "query",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orphanDependents",
            "in": "query",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagationPolicy",
            "in": "query",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update the specified Cloud",
        "operationId": "patchNgpcRxtIoV1NamespacedCloud",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Cloud",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/clouds/{name}/status": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read status of the specified Cloud",
        "operationId": "readNgpcRxtIoV1NamespacedCloudStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Cloud",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace status of the specified Cloud",
        "operationId": "replaceNgpcRxtIoV1NamespacedCloudStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Cloud",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update status of the specified Cloud",
        "operationId": "patchNgpcRxtIoV1NamespacedCloudStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Cloud",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Cloud",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/cloudspaces": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind CloudSpace",
        "operationId": "listNgpcRxtIoV1NamespacedCloudSpace",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpaceList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpaceList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        }
      },
      "post": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "create a CloudSpace",
        "operationId": "createNgpcRxtIoV1NamespacedCloudSpace",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete collection of CloudSpace",
        "operationId": "deleteNgpcRxtIoV1CollectionNamespacedCloudSpace",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/cloudspaces/{name}": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read the specified CloudSpace",
        "operationId": "readNgpcRxtIoV1NamespacedCloudSpace",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the CloudSpace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace the specified CloudSpace",
        "operationId": "replaceNgpcRxtIoV1NamespacedCloudSpace",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the CloudSpace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete a CloudSpace",
        "operationId": "deleteNgpcRxtIoV1NamespacedCloudSpace",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the CloudSpace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gracePeriodSeconds",
            "in": "query",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orphanDependents",
            "in": "query",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagationPolicy",
            "in": "query",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update the specified CloudSpace",
        "operationId": "patchNgpcRxtIoV1NamespacedCloudSpace",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the CloudSpace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/cloudspaces/{name}/status": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read status of the specified CloudSpace",
        "operationId": "readNgpcRxtIoV1NamespacedCloudSpaceStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the CloudSpace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace status of the specified CloudSpace",
        "operationId": "replaceNgpcRxtIoV1NamespacedCloudSpaceStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the CloudSpace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update status of the specified CloudSpace",
        "operationId": "patchNgpcRxtIoV1NamespacedCloudSpaceStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the CloudSpace",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "CloudSpace",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/serverclaims": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind ServerClaim",
        "operationId": "listNgpcRxtIoV1NamespacedServerClaim",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaimList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaimList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        }
      },
      "post": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "create a ServerClaim",
        "operationId": "createNgpcRxtIoV1NamespacedServerClaim",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete collection of ServerClaim",
        "operationId": "deleteNgpcRxtIoV1CollectionNamespacedServerClaim",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/serverclaims/{name}": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read the specified ServerClaim",
        "operationId": "readNgpcRxtIoV1NamespacedServerClaim",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClaim",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace the specified ServerClaim",
        "operationId": "replaceNgpcRxtIoV1NamespacedServerClaim",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClaim",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete a ServerClaim",
        "operationId": "deleteNgpcRxtIoV1NamespacedServerClaim",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClaim",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gracePeriodSeconds",
            "in": "query",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orphanDependents",
            "in": "query",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagationPolicy",
            "in": "query",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update the specified ServerClaim",
        "operationId": "patchNgpcRxtIoV1NamespacedServerClaim",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClaim",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/serverclaims/{name}/status": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read status of the specified ServerClaim",
        "operationId": "readNgpcRxtIoV1NamespacedServerClaimStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClaim",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace status of the specified ServerClaim",
        "operationId": "replaceNgpcRxtIoV1NamespacedServerClaimStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClaim",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update status of the specified ServerClaim",
        "operationId": "patchNgpcRxtIoV1NamespacedServerClaimStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClaim",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/spotnodepools": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind SpotNodePool",
        "operationId": "listNgpcRxtIoV1NamespacedSpotNodePool",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePoolList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePoolList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        }
      },
      "post": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "create a SpotNodePool",
        "operationId": "createNgpcRxtIoV1NamespacedSpotNodePool",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete collection of SpotNodePool",
        "operationId": "deleteNgpcRxtIoV1CollectionNamespacedSpotNodePool",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/spotnodepools/{name}": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read the specified SpotNodePool",
        "operationId": "readNgpcRxtIoV1NamespacedSpotNodePool",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the SpotNodePool",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace the specified SpotNodePool",
        "operationId": "replaceNgpcRxtIoV1NamespacedSpotNodePool",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the SpotNodePool",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete a SpotNodePool",
        "operationId": "deleteNgpcRxtIoV1NamespacedSpotNodePool",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the SpotNodePool",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gracePeriodSeconds",
            "in": "query",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orphanDependents",
            "in": "query",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagationPolicy",
            "in": "query",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update the specified SpotNodePool",
        "operationId": "patchNgpcRxtIoV1NamespacedSpotNodePool",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the SpotNodePool",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/spotnodepools/{name}/status": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read status of the specified SpotNodePool",
        "operationId": "readNgpcRxtIoV1NamespacedSpotNodePoolStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the SpotNodePool",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace status of the specified SpotNodePool",
        "operationId": "replaceNgpcRxtIoV1NamespacedSpotNodePoolStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the SpotNodePool",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update status of the specified SpotNodePool",
        "operationId": "patchNgpcRxtIoV1NamespacedSpotNodePoolStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the SpotNodePool",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/subscriptions": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind Subscription",
        "operationId": "listNgpcRxtIoV1NamespacedSubscription",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SubscriptionList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SubscriptionList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "post": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "create a Subscription",
        "operationId": "createNgpcRxtIoV1NamespacedSubscription",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete collection of Subscription",
        "operationId": "deleteNgpcRxtIoV1CollectionNamespacedSubscription",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/subscriptions/{name}": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read the specified Subscription",
        "operationId": "readNgpcRxtIoV1NamespacedSubscription",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Subscription",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace the specified Subscription",
        "operationId": "replaceNgpcRxtIoV1NamespacedSubscription",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Subscription",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete a Subscription",
        "operationId": "deleteNgpcRxtIoV1NamespacedSubscription",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Subscription",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gracePeriodSeconds",
            "in": "query",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orphanDependents",
            "in": "query",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagationPolicy",
            "in": "query",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update the specified Subscription",
        "operationId": "patchNgpcRxtIoV1NamespacedSubscription",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Subscription",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/namespaces/{namespace}/subscriptions/{name}/status": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read status of the specified Subscription",
        "operationId": "readNgpcRxtIoV1NamespacedSubscriptionStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Subscription",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace status of the specified Subscription",
        "operationId": "replaceNgpcRxtIoV1NamespacedSubscriptionStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Subscription",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update status of the specified Subscription",
        "operationId": "patchNgpcRxtIoV1NamespacedSubscriptionStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Subscription",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "path",
            "description": "object name and auth scope, such as for teams and projects",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/organizations": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind Organization",
        "operationId": "listNgpcRxtIoV1Organization",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.OrganizationList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.OrganizationList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        }
      },
      "post": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "create an Organization",
        "operationId": "createNgpcRxtIoV1Organization",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete collection of Organization",
        "operationId": "deleteNgpcRxtIoV1CollectionOrganization",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/organizations/{name}": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read the specified Organization",
        "operationId": "readNgpcRxtIoV1Organization",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Organization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace the specified Organization",
        "operationId": "replaceNgpcRxtIoV1Organization",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Organization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete an Organization",
        "operationId": "deleteNgpcRxtIoV1Organization",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Organization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gracePeriodSeconds",
            "in": "query",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orphanDependents",
            "in": "query",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagationPolicy",
            "in": "query",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update the specified Organization",
        "operationId": "patchNgpcRxtIoV1Organization",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Organization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/organizations/{name}/status": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read status of the specified Organization",
        "operationId": "readNgpcRxtIoV1OrganizationStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Organization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace status of the specified Organization",
        "operationId": "replaceNgpcRxtIoV1OrganizationStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Organization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update status of the specified Organization",
        "operationId": "patchNgpcRxtIoV1OrganizationStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Organization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Organization",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/regions": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind Region",
        "operationId": "listNgpcRxtIoV1Region",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.RegionList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.RegionList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        }
      },
      "post": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "create a Region",
        "operationId": "createNgpcRxtIoV1Region",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete collection of Region",
        "operationId": "deleteNgpcRxtIoV1CollectionRegion",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/regions/{name}": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read the specified Region",
        "operationId": "readNgpcRxtIoV1Region",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Region",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace the specified Region",
        "operationId": "replaceNgpcRxtIoV1Region",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Region",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete a Region",
        "operationId": "deleteNgpcRxtIoV1Region",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Region",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gracePeriodSeconds",
            "in": "query",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orphanDependents",
            "in": "query",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagationPolicy",
            "in": "query",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update the specified Region",
        "operationId": "patchNgpcRxtIoV1Region",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Region",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/regions/{name}/status": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read status of the specified Region",
        "operationId": "readNgpcRxtIoV1RegionStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Region",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace status of the specified Region",
        "operationId": "replaceNgpcRxtIoV1RegionStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Region",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update status of the specified Region",
        "operationId": "patchNgpcRxtIoV1RegionStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Region",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Region",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/serverclaims": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind ServerClaim",
        "operationId": "listNgpcRxtIoV1ServerClaimForAllNamespaces",
        "parameters": [
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaimList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaimList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClaim",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/serverclasses": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind ServerClass",
        "operationId": "listNgpcRxtIoV1ServerClass",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClassList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClassList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        }
      },
      "post": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "create a ServerClass",
        "operationId": "createNgpcRxtIoV1ServerClass",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete collection of ServerClass",
        "operationId": "deleteNgpcRxtIoV1CollectionServerClass",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/serverclasses/{name}": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read the specified ServerClass",
        "operationId": "readNgpcRxtIoV1ServerClass",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClass",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace the specified ServerClass",
        "operationId": "replaceNgpcRxtIoV1ServerClass",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClass",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete a ServerClass",
        "operationId": "deleteNgpcRxtIoV1ServerClass",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClass",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gracePeriodSeconds",
            "in": "query",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orphanDependents",
            "in": "query",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagationPolicy",
            "in": "query",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update the specified ServerClass",
        "operationId": "patchNgpcRxtIoV1ServerClass",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClass",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/serverclasses/{name}/status": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read status of the specified ServerClass",
        "operationId": "readNgpcRxtIoV1ServerClassStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClass",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace status of the specified ServerClass",
        "operationId": "replaceNgpcRxtIoV1ServerClassStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClass",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update status of the specified ServerClass",
        "operationId": "patchNgpcRxtIoV1ServerClassStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the ServerClass",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "ServerClass",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/servers": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind Server",
        "operationId": "listNgpcRxtIoV1Server",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        }
      },
      "post": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "create a Server",
        "operationId": "createNgpcRxtIoV1Server",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete collection of Server",
        "operationId": "deleteNgpcRxtIoV1CollectionServer",
        "parameters": [
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/servers/{name}": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read the specified Server",
        "operationId": "readNgpcRxtIoV1Server",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Server",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace the specified Server",
        "operationId": "replaceNgpcRxtIoV1Server",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Server",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "delete a Server",
        "operationId": "deleteNgpcRxtIoV1Server",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Server",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gracePeriodSeconds",
            "in": "query",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "orphanDependents",
            "in": "query",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "propagationPolicy",
            "in": "query",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update the specified Server",
        "operationId": "patchNgpcRxtIoV1Server",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Server",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/servers/{name}/status": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "read status of the specified Server",
        "operationId": "readNgpcRxtIoV1ServerStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Server",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        }
      },
      "put": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "replace status of the specified Server",
        "operationId": "replaceNgpcRxtIoV1ServerStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Server",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
              }
            },
            "application/yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      },
      "patch": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "partially update status of the specified Server",
        "operationId": "patchNgpcRxtIoV1ServerStatus",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the Server",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldManager",
            "in": "query",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldValidation",
            "in": "query",
            "description": "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/merge-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            },
            "application/apply-patch+yaml": {
              "schema": {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Server",
          "version": "v1"
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/apis/ngpc.rxt.io/v1/spotnodepools": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind SpotNodePool",
        "operationId": "listNgpcRxtIoV1SpotNodePoolForAllNamespaces",
        "parameters": [
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePoolList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePoolList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "SpotNodePool",
          "version": "v1"
        }
      }
    },
    "/apis/ngpc.rxt.io/v1/subscriptions": {
      "get": {
        "tags": [
          "ngpcRxtIo_v1"
        ],
        "description": "list objects of kind Subscription",
        "operationId": "listNgpcRxtIoV1SubscriptionForAllNamespaces",
        "parameters": [
          {
            "name": "allowWatchBookmarks",
            "in": "query",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "continue",
            "in": "query",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fieldSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "labelSelector",
            "in": "query",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "pretty",
            "in": "query",
            "description": "If 'true', then the output is pretty printed.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersion",
            "in": "query",
            "description": "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "resourceVersionMatch",
            "in": "query",
            "description": "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sendInitialEvents",
            "in": "query",
            "description": "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "watch",
            "in": "query",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SubscriptionList"
                }
              },
              "application/yaml": {
                "schema": {
                  "$ref": "#/components/schemas/io.rxt.ngpc.v1.SubscriptionList"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {}
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "ngpc.rxt.io",
          "kind": "Subscription",
          "version": "v1"
        }
      }
    }
  },
  "components": {
    "schemas": {
      "io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "dryRun": {
            "type": "array",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "items": {
              "type": "string"
            }
          },
          "gracePeriodSeconds": {
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "format": "int64"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "orphanDependents": {
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both."
          },
          "preconditions": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions"
          },
          "propagationPolicy": {
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground."
          }
        },
        "description": "DeleteOptions may be provided when deleting an API object.",
        "x-kubernetes-group-version-kind": [
          {
            "group": "",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "admission.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "admission.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "admissionregistration.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "admissionregistration.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "admissionregistration.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "apiextensions.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "apiextensions.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "apiregistration.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "apiregistration.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "apps",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "apps",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "apps",
            "kind": "DeleteOptions",
            "version": "v1beta2"
          },
          {
            "group": "authentication.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "authentication.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "authentication.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "autoscaling",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "autoscaling",
            "kind": "DeleteOptions",
            "version": "v2"
          },
          {
            "group": "autoscaling",
            "kind": "DeleteOptions",
            "version": "v2beta1"
          },
          {
            "group": "autoscaling",
            "kind": "DeleteOptions",
            "version": "v2beta2"
          },
          {
            "group": "batch",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "batch",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "certificates.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "certificates.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "certificates.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "coordination.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "coordination.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "discovery.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "discovery.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "events.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "events.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "extensions",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta2"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta3"
          },
          {
            "group": "imagepolicy.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "internal.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "networking.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "networking.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "networking.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "node.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "node.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "node.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "policy",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "policy",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "resource.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha2"
          },
          {
            "group": "scheduling.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "scheduling.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "scheduling.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "storage.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "storage.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "storage.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          }
        ]
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1": {
        "type": "object",
        "description": "FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.\n\nEach key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.\n\nThe exact format is defined in sigs.k8s.io/structured-merge-diff"
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta": {
        "type": "object",
        "properties": {
          "continue": {
            "type": "string",
            "description": "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message."
          },
          "remainingItemCount": {
            "type": "integer",
            "description": "remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.",
            "format": "int64"
          },
          "resourceVersion": {
            "type": "string",
            "description": "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"
          },
          "selfLink": {
            "type": "string",
            "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system."
          }
        },
        "description": "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}."
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted."
          },
          "fieldsType": {
            "type": "string",
            "description": "FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: \"FieldsV1\""
          },
          "fieldsV1": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1"
          },
          "manager": {
            "type": "string",
            "description": "Manager is an identifier of the workflow managing these fields."
          },
          "operation": {
            "type": "string",
            "description": "Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'."
          },
          "subresource": {
            "type": "string",
            "description": "Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource."
          },
          "time": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
          }
        },
        "description": "ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to."
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta": {
        "type": "object",
        "properties": {
          "annotations": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations"
          },
          "creationTimestamp": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
          },
          "deletionGracePeriodSeconds": {
            "type": "integer",
            "description": "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
            "format": "int64"
          },
          "deletionTimestamp": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
          },
          "finalizers": {
            "type": "array",
            "description": "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.",
            "items": {
              "type": "string"
            },
            "x-kubernetes-patch-strategy": "merge"
          },
          "generateName": {
            "type": "string",
            "description": "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"
          },
          "generation": {
            "type": "integer",
            "description": "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
            "format": "int64"
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels"
          },
          "managedFields": {
            "type": "array",
            "description": "ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.",
            "items": {
              "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry"
            }
          },
          "name": {
            "type": "string",
            "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces"
          },
          "ownerReferences": {
            "type": "array",
            "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
            "items": {
              "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference"
            },
            "x-kubernetes-patch-strategy": "merge",
            "x-kubernetes-patch-merge-key": "uid"
          },
          "resourceVersion": {
            "type": "string",
            "description": "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"
          },
          "selfLink": {
            "type": "string",
            "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system."
          },
          "uid": {
            "type": "string",
            "description": "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
          }
        },
        "description": "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference": {
        "required": [
          "apiVersion",
          "kind",
          "name",
          "uid"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "API version of the referent."
          },
          "blockOwnerDeletion": {
            "type": "boolean",
            "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned."
          },
          "controller": {
            "type": "boolean",
            "description": "If true, this reference points to the managing controller."
          },
          "kind": {
            "type": "string",
            "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "name": {
            "type": "string",
            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names"
          },
          "uid": {
            "type": "string",
            "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
          }
        },
        "description": "OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.",
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.Patch": {
        "type": "object",
        "description": "Patch is provided to give a concrete name and type to the Kubernetes PATCH request body."
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions": {
        "type": "object",
        "properties": {
          "resourceVersion": {
            "type": "string",
            "description": "Specifies the target ResourceVersion"
          },
          "uid": {
            "type": "string",
            "description": "Specifies the target UID."
          }
        },
        "description": "Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out."
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.Status": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "code": {
            "type": "integer",
            "description": "Suggested HTTP return code for this status, 0 if not set.",
            "format": "int32"
          },
          "details": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "message": {
            "type": "string",
            "description": "A human-readable description of the status of this operation."
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          },
          "reason": {
            "type": "string",
            "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it."
          },
          "status": {
            "type": "string",
            "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status"
          }
        },
        "description": "Status is a return value for calls that don't return other objects.",
        "x-kubernetes-group-version-kind": [
          {
            "group": "",
            "kind": "Status",
            "version": "v1"
          },
          {
            "group": "resource.k8s.io",
            "kind": "Status",
            "version": "v1alpha2"
          }
        ]
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string",
            "description": "The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\""
          },
          "message": {
            "type": "string",
            "description": "A human-readable description of the cause of the error.  This field may be presented as-is to a reader."
          },
          "reason": {
            "type": "string",
            "description": "A machine-readable description of the cause of the error. If this value is empty there is no information available."
          }
        },
        "description": "StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered."
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails": {
        "type": "object",
        "properties": {
          "causes": {
            "type": "array",
            "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
            "items": {
              "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause"
            }
          },
          "group": {
            "type": "string",
            "description": "The group attribute of the resource associated with the status StatusReason."
          },
          "kind": {
            "type": "string",
            "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "name": {
            "type": "string",
            "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described)."
          },
          "retryAfterSeconds": {
            "type": "integer",
            "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
            "format": "int32"
          },
          "uid": {
            "type": "string",
            "description": "UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
          }
        },
        "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined."
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.Time": {
        "type": "string",
        "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
        "format": "date-time"
      },
      "io.rxt.ngpc.v1.Cloud": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
          },
          "spec": {
            "required": [
              "organization"
            ],
            "type": "object",
            "properties": {
              "fqdn": {
                "type": "string",
                "description": "FQDN contains the hostname under which this cloud is reachable. Setting this field will disable discovery and override any discovered FQDN. \n Example: foo-bar.example.com"
              },
              "organization": {
                "type": "string",
                "description": "Organization contains a reference to the Organization to whom this Cloud belongs to."
              }
            },
            "description": "CloudSpec defines the desired state of Cloud"
          },
          "status": {
            "type": "object",
            "properties": {
              "conditions": {
                "type": "array",
                "description": "Conditions defines current service state of the Cloud.",
                "items": {
                  "required": [
                    "lastTransitionTime",
                    "status",
                    "type"
                  ],
                  "type": "object",
                  "properties": {
                    "lastTransitionTime": {
                      "type": "string",
                      "description": "Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.",
                      "format": "date-time"
                    },
                    "message": {
                      "type": "string",
                      "description": "A human readable message indicating details about the transition. This field may be empty."
                    },
                    "reason": {
                      "type": "string",
                      "description": "The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty."
                    },
                    "severity": {
                      "type": "string",
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False."
                    },
                    "status": {
                      "type": "string",
                      "description": "Status of the condition, one of True, False, Unknown."
                    },
                    "type": {
                      "type": "string",
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important."
                    }
                  },
                  "description": "Condition defines an observation of a Cluster API resource operational state."
                }
              },
              "embark": {
                "type": "object",
                "properties": {
                  "embarkState": {
                    "type": "string"
                  },
                  "fqdn": {
                    "type": "string"
                  },
                  "namespace": {
                    "type": "string"
                  },
                  "shortName": {
                    "type": "string"
                  },
                  "taskState": {
                    "type": "string"
                  }
                },
                "description": "Embark contains additional status info about the Cloud from the Embark service."
              },
              "fqdn": {
                "type": "string",
                "description": "FQDN contains the hostname under which this cloud is reachable. This is either the FQDN set in the CloudSpec or the FQDN generated by Embark. \n Example: foo.bar.example.com"
              },
              "phase": {
                "type": "string",
                "description": "Phase indicates the current state of the Cloud."
              },
              "reason": {
                "type": "string",
                "description": "Reason contains the reason why the Cloud is in a certain phase."
              },
              "vcp": {
                "type": "object",
                "properties": {
                  "namespace": {
                    "type": "string",
                    "description": "Namespace describes the namespace in which the managed control planes of this Cloud are deployed."
                  }
                },
                "description": "VCP contains additional status info about the virtual control planes associated with this Cloud."
              }
            },
            "description": "CloudStatus defines the observed state of Cloud"
          }
        },
        "description": "Cloud is the Schema for the clouds API",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "Cloud",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.CloudList": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "items": {
            "type": "array",
            "description": "List of clouds. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "items": {
              "$ref": "#/components/schemas/io.rxt.ngpc.v1.Cloud"
            }
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          }
        },
        "description": "CloudList is a list of Cloud",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "CloudList",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.CloudSpace": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
          },
          "spec": {
            "required": [
              "cloud",
              "region"
            ],
            "type": "object",
            "properties": {
              "HAControlPlane": {
                "type": "boolean",
                "description": "Set to Enable control plane HA and setting HACount"
              },
              "bidRequests": {
                "type": "array",
                "description": "Contains a list of SpotNodePool requests",
                "items": {
                  "type": "string"
                }
              },
              "cloud": {
                "type": "string",
                "description": "Cloud describes to which Cloud the CloudSpace belongs to."
              },
              "clusterRef": {
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "type": "string",
                    "description": "API version of the referent."
                  },
                  "fieldPath": {
                    "type": "string",
                    "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future."
                  },
                  "kind": {
                    "type": "string",
                    "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
                  },
                  "namespace": {
                    "type": "string",
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"
                  },
                  "resourceVersion": {
                    "type": "string",
                    "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"
                  },
                  "uid": {
                    "type": "string",
                    "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids"
                  }
                },
                "description": "ClusterRef contains a reference to the Cluster in PMK. Setting this field will disable discovery and override any discovered cluster. \n - If it is a Qbert Cluster, the Kind will be \"QbertCluster\", the namespace will be the project ID, and the name will be the ID. - If it is a CAPI Cluster, the kind will be \"Cluster\".",
                "x-kubernetes-map-type": "atomic"
              },
              "networks": {
                "type": "array",
                "description": "Networks contain the configuration of the VM networks in this CloudSpace.",
                "items": {
                  "required": [
                    "name"
                  ],
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string"
                    },
                    "subnet": {
                      "type": "string"
                    }
                  }
                }
              },
              "region": {
                "type": "string",
                "description": "Region specifies the region which the CloudSpace should be in."
              },
              "servers": {
                "type": "array",
                "description": "Servers contains the requested set of servers for this CloudSpace.",
                "items": {
                  "required": [
                    "class",
                    "count"
                  ],
                  "type": "object",
                  "properties": {
                    "class": {
                      "type": "string"
                    },
                    "count": {
                      "type": "integer"
                    }
                  }
                }
              },
              "type": {
                "type": "string",
                "description": "Type of CloudSpace"
              },
              "webhook": {
                "type": "string",
                "description": "Optional webhook that will be invoked when Servers of this CloudSpace are released"
              }
            },
            "description": "CloudSpaceSpec defines the desired state of CloudSpace"
          },
          "status": {
            "type": "object",
            "properties": {
              "APIServerEndpoint": {
                "type": "string"
              },
              "assignedServers": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "IP": {
                      "type": "string"
                    },
                    "clusterRole": {
                      "type": "string"
                    },
                    "error": {
                      "type": "string"
                    },
                    "serverClassName": {
                      "type": "string"
                    },
                    "serverName": {
                      "type": "string"
                    },
                    "state": {
                      "type": "string"
                    }
                  }
                },
                "description": "ServerStatus contains status of servers configuring"
              },
              "bids": {
                "type": "object",
                "additionalProperties": {
                  "required": [
                    "bidName",
                    "wonCount"
                  ],
                  "type": "object",
                  "properties": {
                    "bidName": {
                      "type": "string"
                    },
                    "wonCount": {
                      "type": "integer"
                    }
                  }
                },
                "description": "Map of each bid and it's WonCount status"
              },
              "clusterRef": {
                "type": "object",
                "properties": {
                  "apiVersion": {
                    "type": "string",
                    "description": "API version of the referent."
                  },
                  "fieldPath": {
                    "type": "string",
                    "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future."
                  },
                  "kind": {
                    "type": "string",
                    "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
                  },
                  "namespace": {
                    "type": "string",
                    "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"
                  },
                  "resourceVersion": {
                    "type": "string",
                    "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"
                  },
                  "uid": {
                    "type": "string",
                    "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids"
                  }
                },
                "description": "ClusterRef contains a reference to the Cluster in PMK. \n - If it is a Qbert Cluster, the Kind will be \"QbertCluster\", the namespace will be the project ID, the name will be the cluster name, and the UID will be the cluster ID. - If it is a CAPI Cluster, the kind will be \"Cluster\".",
                "x-kubernetes-map-type": "atomic"
              },
              "conditions": {
                "type": "array",
                "description": "Conditions defines current service state of the CloudSpace.",
                "items": {
                  "required": [
                    "lastTransitionTime",
                    "status",
                    "type"
                  ],
                  "type": "object",
                  "properties": {
                    "lastTransitionTime": {
                      "type": "string",
                      "description": "Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.",
                      "format": "date-time"
                    },
                    "message": {
                      "type": "string",
                      "description": "A human readable message indicating details about the transition. This field may be empty."
                    },
                    "reason": {
                      "type": "string",
                      "description": "The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty."
                    },
                    "severity": {
                      "type": "string",
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False."
                    },
                    "status": {
                      "type": "string",
                      "description": "Status of the condition, one of True, False, Unknown."
                    },
                    "type": {
                      "type": "string",
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important."
                    }
                  },
                  "description": "Condition defines an observation of a Cluster API resource operational state."
                }
              },
              "health": {
                "type": "string",
                "description": "Health indicates if CloudSpace has a working APIServer and available nodes"
              },
              "pendingAllocations": {
                "type": "object",
                "additionalProperties": {
                  "required": [
                    "count",
                    "serverClassName"
                  ],
                  "type": "object",
                  "properties": {
                    "bidName": {
                      "type": "string"
                    },
                    "count": {
                      "type": "integer"
                    },
                    "serverClassName": {
                      "type": "string"
                    }
                  }
                },
                "description": "Outstanding pooler Allocation IDs for Cloud Instances"
              },
              "phase": {
                "type": "string",
                "description": "Phase indicates the current state of the Cloud."
              },
              "reason": {
                "type": "string",
                "description": "Reason contains the reason why the CloudSpace is in a certain phase."
              },
              "sshSecretName": {
                "type": "string",
                "description": "SSHSecretName contains the SSH Key Secret to access nodes in the CloudSpace"
              }
            },
            "description": "CloudSpaceStatus defines the observed state of CloudSpace"
          }
        },
        "description": "CloudSpace is the Schema for the cloudspaces API",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "CloudSpace",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.CloudSpaceList": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "items": {
            "type": "array",
            "description": "List of cloudspaces. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "items": {
              "$ref": "#/components/schemas/io.rxt.ngpc.v1.CloudSpace"
            }
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          }
        },
        "description": "CloudSpaceList is a list of CloudSpace",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "CloudSpaceList",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.Organization": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
          },
          "spec": {
            "type": "object",
            "properties": {
              "branding": {
                "type": "object",
                "properties": {
                  "logoURL": {
                    "type": "string"
                  }
                }
              },
              "disableDefaultCloud": {
                "type": "boolean",
                "description": "DisableDefaultCloud will disable creating the default Cloud instance for this organization."
              },
              "displayName": {
                "type": "string",
                "description": "DisplayName specifies the human-readable name to use. If not set, the spec.name or metadata.name should be used."
              },
              "name": {
                "type": "string",
                "description": "Name specifies the name used as an identifier."
              }
            },
            "description": "OrganizationSpec defines the desired state of Organization"
          },
          "status": {
            "type": "object",
            "properties": {
              "conditions": {
                "type": "array",
                "description": "Conditions defines current service state of the Organization.",
                "items": {
                  "required": [
                    "lastTransitionTime",
                    "status",
                    "type"
                  ],
                  "type": "object",
                  "properties": {
                    "lastTransitionTime": {
                      "type": "string",
                      "description": "Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.",
                      "format": "date-time"
                    },
                    "message": {
                      "type": "string",
                      "description": "A human readable message indicating details about the transition. This field may be empty."
                    },
                    "reason": {
                      "type": "string",
                      "description": "The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty."
                    },
                    "severity": {
                      "type": "string",
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False."
                    },
                    "status": {
                      "type": "string",
                      "description": "Status of the condition, one of True, False, Unknown."
                    },
                    "type": {
                      "type": "string",
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important."
                    }
                  },
                  "description": "Condition defines an observation of a Cluster API resource operational state."
                }
              },
              "namespace": {
                "type": "string",
                "description": "Namespace contains the name of the namespace that belongs to this Organization."
              },
              "phase": {
                "type": "string",
                "description": "Phase indicates the current state of the Organization."
              },
              "reason": {
                "type": "string",
                "description": "Reason contains the reason why the Organization is in a certain phase."
              }
            },
            "description": "OrganizationStatus defines the observed state of Organization"
          }
        },
        "description": "Organization is the Schema for the organizations API",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "Organization",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.OrganizationList": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "items": {
            "type": "array",
            "description": "List of organizations. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "items": {
              "$ref": "#/components/schemas/io.rxt.ngpc.v1.Organization"
            }
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          }
        },
        "description": "OrganizationList is a list of Organization",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "OrganizationList",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.Region": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
          },
          "spec": {
            "required": [
              "provider"
            ],
            "type": "object",
            "properties": {
              "country": {
                "maxLength": 3,
                "minLength": 3,
                "type": "string",
                "description": "Country describes the country the region is located in. It should adhere to the \"ISO 3166-1 alpha-3\" standard. See: https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes"
              },
              "description": {
                "type": "string",
                "description": "Description is a free-form field to provide further description of the region's location."
              },
              "provider": {
                "required": [
                  "providerRegionName",
                  "providerType"
                ],
                "type": "object",
                "properties": {
                  "providerRegionName": {
                    "type": "string"
                  },
                  "providerType": {
                    "type": "string",
                    "description": "ProviderSpec describes the actual infrastructure/cloud Provider backing the region For example, ironic, ospc, or whatever other clouds we may support"
                  }
                },
                "description": "ProviderSpec describes the actual infrastructure/cloud backing the region For example, ironic, ospc, or whatever other clouds we may support"
              }
            },
            "description": "RegionSpec defines the desired state of Region"
          }
        },
        "description": "Region is the Schema for the regions API",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "Region",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.RegionList": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "items": {
            "type": "array",
            "description": "List of regions. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "items": {
              "$ref": "#/components/schemas/io.rxt.ngpc.v1.Region"
            }
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          }
        },
        "description": "RegionList is a list of Region",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "RegionList",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.Server": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
          },
          "spec": {
            "required": [
              "region",
              "resources",
              "serverClassName"
            ],
            "type": "object",
            "properties": {
              "accessSecretName": {
                "type": "string",
                "description": "AccessSecretName refers to kube secret ref containing the SSH credentials to access the node"
              },
              "ipAddress": {
                "type": "string",
                "description": "IPAddress contains the IP address to access the node"
              },
              "macAddress": {
                "type": "string",
                "description": "MACAddress contains MAC address of the pxe interface on the node"
              },
              "region": {
                "type": "string",
                "description": "Region describes in which region this server is located."
              },
              "resources": {
                "type": "object",
                "properties": {
                  "cpu": {
                    "type": "string"
                  },
                  "memory": {
                    "type": "string"
                  }
                },
                "description": "Resources contains the characteristics of the server."
              },
              "serverClaimRef": {
                "required": [
                  "name",
                  "namespace"
                ],
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "ServerClaim name this server is claimed by."
                  },
                  "namespace": {
                    "type": "string",
                    "description": "ServerClaim's namespace this server is claimed by."
                  }
                },
                "description": "ServerClaimRef has reference to current reservation's ServerClaim"
              },
              "serverClassName": {
                "type": "string",
                "description": "ServerClass the Server belongs to"
              }
            },
            "description": "ServerSpec defines the desired state of Server"
          },
          "status": {
            "type": "object",
            "properties": {
              "ironicPhase": {
                "type": "string",
                "description": "IronicPhase indicates the Ironic Phase the node is in"
              },
              "phase": {
                "type": "string",
                "description": "Phase indicates the current state of the Server."
              }
            },
            "description": "ServerStatus defines the observed state of Server"
          }
        },
        "description": "Server is the Schema for the servers API",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "Server",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.ServerClaim": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
          },
          "spec": {
            "required": [
              "cloud",
              "cloudspace",
              "pricing",
              "serverclass",
              "servername"
            ],
            "type": "object",
            "properties": {
              "cloud": {
                "type": "string",
                "description": "Cloud describes to which Cloud the claim belongs to."
              },
              "cloudspace": {
                "type": "string",
                "description": "CloudSpace describes to which CloudSpace does this claim belongs to."
              },
              "pricing": {
                "required": [
                  "cost",
                  "type"
                ],
                "type": "object",
                "properties": {
                  "cost": {
                    "type": "string",
                    "description": "Cost describes the =USD cost of this type of servers."
                  },
                  "interval": {
                    "type": "string",
                    "description": "Interval indicates the interval used for the pricing. The format is a golang duration string, for example: 20s, 6m, or 1h6m. Currently, only 1h interval is supported"
                  },
                  "type": {
                    "type": "string",
                    "description": "Type describes if pricing is ondemand(fixed) or spot(variable)"
                  }
                },
                "description": "Pricing describes the price at which this server was claimed"
              },
              "serverclass": {
                "type": "string",
                "description": "ServerClass specifies the serverclass of the server that is claimed."
              },
              "servername": {
                "type": "string",
                "description": "ServerName specifies the server that is claimed."
              }
            },
            "description": "ServerClaimSpec defines the desired state of ServerClaim"
          },
          "status": {
            "required": [
              "phase"
            ],
            "type": "object",
            "properties": {
              "phase": {
                "type": "string",
                "description": "Phase indicates the current state of the ServerClaim."
              },
              "releasedAt": {
                "type": "string",
                "description": "ReleasedAt indicates the datetime at which the claim was unreserved, if phase is unreserved."
              }
            },
            "description": "ServerClaimStatus defines the observed state of ServerClaim"
          }
        },
        "description": "ServerClaim is the Schema for the serverclaim API",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "ServerClaim",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.ServerClaimList": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "items": {
            "type": "array",
            "description": "List of serverclaims. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "items": {
              "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClaim"
            }
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          }
        },
        "description": "ServerClaimList is a list of ServerClaim",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "ServerClaimList",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.ServerClass": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
          },
          "spec": {
            "required": [
              "provider",
              "region"
            ],
            "type": "object",
            "properties": {
              "category": {
                "type": "string",
                "description": "Category is a loose grouping of ServerClasses into different flavor types For example, general, compute, memory"
              },
              "displayName": {
                "type": "string",
                "description": "DisplayName specifies the human-readable name to use. If not set, the metadata.name should be used."
              },
              "flavorType": {
                "type": "string",
                "description": "FlavorType describes whether it is a VM or bare metal. This determines certain capabilities like nested virtualization"
              },
              "onDemandPricing": {
                "required": [
                  "cost"
                ],
                "type": "object",
                "properties": {
                  "cost": {
                    "type": "string",
                    "description": "Cost describes the =USD cost of this type of servers. If pricing is localized, this can be used as the base factor."
                  },
                  "interval": {
                    "type": "string",
                    "description": "Interval indicates the interval used for the pricing. The format is a golang duration string, for example: 20s, 6m, or 1h6m."
                  }
                },
                "description": "OnDemandPricing contains a basic ondemand pricing for this type of servers."
              },
              "provider": {
                "required": [
                  "providerFlavorID",
                  "providerType"
                ],
                "type": "object",
                "properties": {
                  "providerFlavorID": {
                    "type": "string",
                    "description": "ProviderFlavorID is the actual flavor ID in the cloud Since ServerClass.Name will be region-specific"
                  },
                  "providerType": {
                    "type": "string",
                    "description": "ProviderType indicates OSPC vs Ironic, etc..."
                  }
                },
                "description": "Provider contails provider specific names for the flavor and type of cloud"
              },
              "region": {
                "type": "string",
                "description": "Region specifies the region where the servers belonging to this ServerClass resides in."
              },
              "resources": {
                "type": "object",
                "properties": {
                  "cpu": {
                    "type": "string"
                  },
                  "memory": {
                    "type": "string"
                  }
                },
                "description": "Resources contains the characteristics of the servers that are part of this class of servers."
              }
            },
            "description": "ServerClassSpec defines the desired state of ServerClass"
          },
          "status": {
            "type": "object",
            "properties": {
              "available": {
                "type": "integer",
                "description": "Available indicates how many servers of this class are available to be provisioned."
              },
              "capacity": {
                "type": "integer",
                "description": "Capacity describes how many servers are available both online and offline."
              },
              "lastAuction": {
                "type": "integer"
              },
              "reserved": {
                "type": "integer",
                "description": "Reserved shows how many servers of this class are currently in use by organizations."
              },
              "spotPricing": {
                "required": [
                  "hammerPricePerHour",
                  "marketPricePerHour"
                ],
                "type": "object",
                "properties": {
                  "hammerPricePerHour": {
                    "type": "string",
                    "description": "HammerPricePerHour describes the current =USD cost per hour being billed for this type of servers if reserved as spot. This is intended to be used as an indicator and will vary based on Market conditions."
                  },
                  "marketPricePerHour": {
                    "type": "string",
                    "description": "MarketPricePerHour describes the current =USD cost per hour of this type of servers if reserved as spot. This is intended to be used as an indicator and will vary based on Market conditions."
                  }
                },
                "description": "SpotPricing contains a basic spot pricing for this type of servers. This is updated from Auction Controller based on Auction results and market variations."
              }
            },
            "description": "ServerClassStatus defines the observed state of ServerClass"
          }
        },
        "description": "ServerClass is the Schema for the serverclasses API",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "ServerClass",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.ServerClassList": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "items": {
            "type": "array",
            "description": "List of serverclasses. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "items": {
              "$ref": "#/components/schemas/io.rxt.ngpc.v1.ServerClass"
            }
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          }
        },
        "description": "ServerClassList is a list of ServerClass",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "ServerClassList",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.ServerList": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "items": {
            "type": "array",
            "description": "List of servers. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "items": {
              "$ref": "#/components/schemas/io.rxt.ngpc.v1.Server"
            }
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          }
        },
        "description": "ServerList is a list of Server",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "ServerList",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.SpotNodePool": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
          },
          "spec": {
            "required": [
              "bidPrice",
              "cloudSpace",
              "desired",
              "serverClass"
            ],
            "type": "object",
            "properties": {
              "bidPrice": {
                "type": "string"
              },
              "cloudSpace": {
                "type": "string"
              },
              "desired": {
                "type": "integer"
              },
              "serverClass": {
                "type": "string"
              },
              "webhook": {
                "type": "string"
              }
            },
            "description": "SpotNodePoolSpec defines the desired state of SpotNodePool"
          },
          "status": {
            "required": [
              "bidStatus"
            ],
            "type": "object",
            "properties": {
              "bidStatus": {
                "type": "string"
              },
              "wonCount": {
                "type": "integer"
              }
            },
            "description": "SpotNodePoolStatus defines the observed state of SpotNodePool"
          }
        },
        "description": "SpotNodePool is the Schema for the spotnodepools API",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "SpotNodePool",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.SpotNodePoolList": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "items": {
            "type": "array",
            "description": "List of spotnodepools. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "items": {
              "$ref": "#/components/schemas/io.rxt.ngpc.v1.SpotNodePool"
            }
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          }
        },
        "description": "SpotNodePoolList is a list of SpotNodePool",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "SpotNodePoolList",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.Subscription": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
          },
          "spec": {
            "required": [
              "customerId",
              "subscriptionId"
            ],
            "type": "object",
            "properties": {
              "customerId": {
                "type": "string",
                "description": "CustomerId is the stripe customer ID"
              },
              "subscriptionId": {
                "type": "string",
                "description": "SubscriptionId is the stripe subscription ID associated with the CustomerId"
              }
            },
            "description": "SubscriptionSpec defines the desired state of Region"
          },
          "status": {
            "type": "object",
            "properties": {
              "conditions": {
                "type": "array",
                "description": "Conditions defines current service state of the UsageReporting.",
                "items": {
                  "required": [
                    "lastTransitionTime",
                    "status",
                    "type"
                  ],
                  "type": "object",
                  "properties": {
                    "lastTransitionTime": {
                      "type": "string",
                      "description": "Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.",
                      "format": "date-time"
                    },
                    "message": {
                      "type": "string",
                      "description": "A human readable message indicating details about the transition. This field may be empty."
                    },
                    "reason": {
                      "type": "string",
                      "description": "The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty."
                    },
                    "severity": {
                      "type": "string",
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False."
                    },
                    "status": {
                      "type": "string",
                      "description": "Status of the condition, one of True, False, Unknown."
                    },
                    "type": {
                      "type": "string",
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important."
                    }
                  },
                  "description": "Condition defines an observation of a Cluster API resource operational state."
                }
              },
              "lastUsageReportedTime": {
                "type": "string",
                "description": "LastUsageReportedTime indicates the time when the last usage was reported for this subscription. This is generally the time when `invoice.upcoming` webhook was raised, which is few days before when the actual invoice is created"
              },
              "status": {
                "type": "string",
                "description": "Status contains the status - active: when payment is set up and good - inactive: when payment has failed or has not been set up yet"
              },
              "statusReason": {
                "type": "string",
                "description": "StatusReason contains the reason why the subscription is in a certain status."
              },
              "usageReportingStatus": {
                "type": "string",
                "description": "UsageReportingStatus indicates if usage reporting needs to be done for this subscription."
              },
              "usageReportingStatusReason": {
                "type": "string",
                "description": "UsageReportingStatusReason indicates the reason why the UsageReporting is in a certain status."
              }
            },
            "description": "SubscriptionStatus defines the observed state of Subscription"
          }
        },
        "description": "Subscription is the Schema for the regions API",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "Subscription",
            "version": "v1"
          }
        ]
      },
      "io.rxt.ngpc.v1.SubscriptionList": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
          },
          "items": {
            "type": "array",
            "description": "List of subscriptions. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "items": {
              "$ref": "#/components/schemas/io.rxt.ngpc.v1.Subscription"
            }
          },
          "kind": {
            "type": "string",
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
          },
          "metadata": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
          }
        },
        "description": "SubscriptionList is a list of Subscription",
        "x-kubernetes-group-version-kind": [
          {
            "group": "ngpc.rxt.io",
            "kind": "SubscriptionList",
            "version": "v1"
          }
        ]
      }
    },
    "securitySchemes": {
      "BearerToken": {
        "type": "apiKey",
        "description": "Bearer Token authentication",
        "name": "authorization",
        "in": "header"
      }
    }
  },
  "x-original-swagger-version": "2.0"
}